<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<title>Introduction to Monkey C</title>
	<meta name="author" content="Garmin International"/>
	<meta name="date" content="July 10, 2020"/>
	<link type="text/css" rel="stylesheet" href="resources/programmers-guide/style.css"/>
	<meta name="copyright" content="Introduction to Monkey C version 3.2, Copyright 2020 Garmin, International."/>
</head>
<body>

<link href="resources/programmers-guide/google-code-prettify/prettify.css" type="text/css" rel="stylesheet" />
<script src="resources/programmers-guide/jquery-1.11.3.min.js"></script>
<script>
    $(document).ready( function() {
        $( 'pre' ).addClass( 'prettyprint' );
    } );
</script>
<script src="resources/programmers-guide/google-code-prettify/run_prettify.js"></script>
<div id="connect_iq_logo">
<figure>
<img src="resources/programmers-guide/connect_iq_logo.png" style="max-width:471px;" title="Powered by Garmin" />
</figure>
</div>
<div id="title">Introduction to Monkey C</div>
<div id="tagline">Learning the Language You Didn&#8217;t Know You Already Knew</div>
<div class="clear"></div>

<h1 id="tableofcontents">Table of Contents</h1>
<div id="toc">

<ul>
<li><a href="#hellomonkeyc">Hello Monkey C!</a>

<ul>
<li><a href="#differencesfromotherlanguages">Differences From Other Languages</a>

<ul>
<li><a href="#java">Java</a></li>
<li><a href="#luajavascript">Lua/JavaScript</a></li>
<li><a href="#rubypythonandphp">Ruby, Python, and PHP</a></li>
</ul></li>
</ul></li>
<li><a href="#objectsmodulesandmemory">Objects, Modules, and Memory</a>

<ul>
<li><a href="#constructors">Constructors</a></li>
<li><a href="#inheritance">Inheritance</a></li>
<li><a href="#datahiding">Data Hiding</a></li>
<li><a href="#polymorphism">Polymorphism</a></li>
<li><a href="#strongandweakreferences">Strong and Weak References</a>

<ul>
<li><a href="#handlesandheapallocation">Handles and Heap Allocation</a></li>
</ul></li>
<li><a href="#modules">Modules</a>

<ul>
<li><a href="#usingstatements">Using Statements</a></li>
</ul></li>
<li><a href="#apisandapptypes">APIs and App Types</a></li>
<li><a href="#scoping">Scoping</a></li>
</ul></li>
<li><a href="#functions">Functions</a>

<ul>
<li><a href="#variablesexpressionsandoperators">Variables, Expressions, and Operators</a>

<ul>
<li><a href="#keywords">Keywords</a></li>
<li><a href="#declaringvariables">Declaring Variables</a></li>
<li><a href="#symbols">Symbols</a></li>
<li><a href="#constants">Constants</a></li>
<li><a href="#enumerations">Enumerations</a></li>
<li><a href="#callingmethodsandfunctions">Calling Methods and Functions</a></li>
<li><a href="#ifstatements">If Statements</a></li>
<li><a href="#switchstatements">Switch Statements</a></li>
<li><a href="#switchblockvariablescoping">Switch Block Variable Scoping</a></li>
<li><a href="#loops">Loops</a></li>
<li><a href="#returningvaluesfromfunctions">Returning Values From Functions</a></li>
<li><a href="#instanceofandhas">Instanceof and Has</a></li>
</ul></li>
<li><a href="#callbacks">Callbacks</a></li>
</ul></li>
<li><a href="#containers">Containers</a>

<ul>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#dictionaries">Dictionaries</a></li>
</ul></li>
<li><a href="#exceptionsanderrors">Exceptions and Errors</a>

<ul>
<li><a href="#creatinganexception">Creating an Exception</a></li>
<li><a href="#errors">Errors</a></li>
</ul></li>
<li><a href="#annotations">Annotations</a></li>
<li><a href="#codingconventions">Coding Conventions</a>

<ul>
<li><a href="#naming">Naming</a></li>
<li><a href="#source">Source</a></li>
<li><a href="#definitions">Definitions</a></li>
<li><a href="#sample">Sample</a></li>
</ul></li>
<li><a href="#monkeytypescomingsoon">Monkey Types (COMING SOON)</a>

<ul>
<li><a href="#theimportstatement">The import Statement</a></li>
<li><a href="#theasclause">The as Clause</a></li>
<li><a href="#namedversusanonymoustypes">Named Versus Anonymous Types</a></li>
<li><a href="#types">Types</a>

<ul>
<li><a href="#any">Any</a></li>
<li><a href="#void">Void</a></li>
<li><a href="#concrete">Concrete</a></li>
<li><a href="#poly">Poly</a></li>
<li><a href="#interface">Interface</a></li>
<li><a href="#container">Container</a></li>
<li><a href="#dictionary">Dictionary</a></li>
<li><a href="#enumerations-1">Enumerations</a></li>
<li><a href="#callback">Callback</a></li>
<li><a href="#null">Null</a></li>
</ul></li>
<li><a href="#typematchingandambiguity">Type Matching and Ambiguity</a></li>
<li><a href="#typingwithinfunctions">Typing Within Functions</a>

<ul>
<li><a href="#returnvaluesandvoid">Return Values and Void</a></li>
<li><a href="#anyandtypeambiguity">Any and Type Ambiguity</a></li>
<li><a href="#typecasting">Type Casting</a></li>
<li><a href="#runtimetypechecking">Runtime Type Checking</a></li>
<li><a href="#if-splitting">If-Splitting</a></li>
</ul></li>
<li><a href="#moduleandclasstyping">Module and Class Typing</a>

<ul>
<li><a href="#typingmembervariables">Typing Member Variables</a></li>
<li><a href="#typesandinheritance">Types and Inheritance</a></li>
</ul></li>
</ul></li>
</ul>
</div>

<h1 id="hellomonkeyc">Hello Monkey C!</h1>
<figure>
<img src="resources/programmers-guide/smart-monkey.png" style="max-width:300px;" title="Code Monkey get up get coffee..." />
</figure>

<p>There is no better way to learn Monkey C than by jumping right in. Let&#8217;s take a look at the application object of a watch face.</p>

<pre><code class="java">using Toybox.Application as App;
using Toybox.System;

class MyProjectApp extends App.AppBase {

    // onStart() is called on application start up
    function onStart(state) {
    }

    // onStop() is called when your application is exiting
    function onStop(state) {
    }

    // Return the initial view of your application here
    function getInitialView() {
        return [ new MyProjectView() ];
    }
}
</code></pre>

<p>If this looks familiar and non-threatening, that&#8217;s the point. Monkey C is intended to be the language you didn&#8217;t know you already knew.</p>

<p>At the top is a using statement, which is analogous to C++&#8217;s <code>using</code> statement, or an <code>import</code> in Java&trade;, Ruby, or Python&trade;. <code>using</code> statements lexically bring modules into our name space. After a <code>using</code> clause, we can refer to a module by its shortened name (in this case <code>System</code>). <code>Toybox</code> is the root module for Monkey C system modules; all the cool toys are kept in there.</p>

<p>To print out values to the debug console, use:</p>

<pre><code class="typescript">System.println( &quot;Hello Monkey C!&quot; );
</code></pre>

<p><code>System</code> refers to the <code>Toybox.System</code> module we imported with the <code>using</code> statement. Unlike Java namespaces, modules in Monkey C are static objects that can contain functions, classes, and variables. The <code>println()</code> function should be familiar to Java programmers&mdash;it prints a string and automatically adds a new line. The <code>System</code> module has a number of useful functions:</p>

<ul>
<li><code>print</code> and <code>println</code> send output to the console</li>
<li><code>getTimer</code> returns the current millisecond timer. The value is a 32 bit integer representing the number of milliseconds the system has been running. The value can be used for timing but is allowed to roll over.</li>
<li><code>getSystemStats</code> provides statistics from the runtime system</li>
<li><code>exit</code> will terminate your application</li>
<li><code>error</code> will exit your application while logging an error message</li>
</ul>

<h2 id="differencesfromotherlanguages">Differences From Other Languages</h2>

<p>As Italian and Spanish derive from Latin, Monkey C derives heavily from other popular languages. C, Java&trade;, JavaScript, Python&trade;, Lua, Ruby, and PHP all influenced the design for Monkey C. If you are familiar with any of those languages, Monkey C should be easy to pick up.</p>

<h3 id="java">Java</h3>

<p>Like Java, Monkey C compiles into byte code that is interpreted by a virtual machine. Also like Java, all objects are allocated on the heap, and the virtual machine cleans up memory (Java through garbage collection, Monkey C through reference counting). Unlike Java, Monkey C does not have primitive types&mdash;integers, floats, and chars are objects. This means primitives can have methods just like other objects.</p>

<p>While Java is a statically typed language, Monkey C is <a href="https://en.wikipedia.org/wiki/Duck_typing"><em>duck typed</em></a>. In Java, the developer must declare the types for all parameters of a function, and declare the return value type. The Java compiler checks these at compile time to ensure type safety. Duck typing is the concept of &#8220;if it walks like a duck, and quacks like a duck, then it must be a duck&#8221;<a href="#fn:1" id="fnref:1" title="see footnote" class="footnote">[1]</a>. For example:</p>

<pre><code class="typescript">function add( a, b ) {
    return a + b;
}

function thisFunctionUsesAdd() {
    var a = add( 1, 3 ); // Return  4
    var b = add( &quot;Hello &quot;, &quot;World&quot; ); // Returns &quot;Hello World&quot;
}
</code></pre>

<p>The Monkey C compiler does not verify type safety, and instead causes a runtime error if a function mishandles a method.</p>

<p>Monkey C modules serve a similar purpose as Java packages, but unlike packages, modules can contain variables and functions. It is common for static methods to exist in the module as opposed to a particular class.</p>

<h3 id="luajavascript">Lua/JavaScript</h3>

<p>The main difference between JavaScript or Lua and Monkey C is that functions in Monkey C are not first class. In JavaScript, a function can be passed to handle a callback:</p>

<pre><code class="javascript">function wakeMeUpBeforeYouGoGo() {
    // Handle completion
}

// Do a long running thing, and pass callback to call when done.
doLongRunningTask( wakeMeUpBeforeYouGoGo );
</code></pre>

<p>In Lua, to create an object, you bind functions to a hash table:</p>

<pre><code class="lua">function doSomethingFunction( me ) {
    // Do something here
}

// Constructor for MyObject
function newMyObject() {
    local result = {};
    result[&quot;doSomething&quot;] = doSomethingFunction;
}
</code></pre>

<p>Neither of these techniques works in Monkey C, because functions are bound to the object they are created in.</p>

<p>To create a callback in Monkey C, create a <em>Method object</em>. Method objects are a combination of the function and the object instance or module they originate from.</p>

<h3 id="rubypythonandphp">Ruby, Python, and PHP</h3>

<p>Objects in Ruby and Python are hash tables, and have many of the properties of hash tables. Functions and variables can be added to objects at run time.</p>

<p>Monkey C objects are compiled and cannot be modified at runtime. All variables have to be declared before they can be used, either in the local function, the class instance, or in the parent module.</p>

<p>When importing a module, all classes inside the module have to be referenced through their parent module. You import modules, not classes, into your namespace.</p>

<h1 id="objectsmodulesandmemory">Objects, Modules, and Memory</h1>

<p>Objects are created with the <code>class</code> keyword. Classes allow data and operations to be bound together on an object. In Monkey C, variables, functions, and other classes can be defined within a class.</p>

<h2 id="constructors">Constructors</h2>

<p>When an object is instantiated with the <code>new</code> keyword, the memory is allocated and the <code>initialize</code> method is called:</p>

<pre><code class="typescript">class Circle
{
    protected var mRadius;
    public function initialize( aRadius ) {
      mRadius = aRadius;
    }
}

function createCircle() {
    var c = new Circle( 1.5 );
}
</code></pre>

<p>Within a method implementation you can refer to your current instance using either the <code>self</code> or <code>me</code> keywords.</p>

<pre><code class="java">class A
{
    public var x;
    public var y;
    public function initialize() {
        me.x = &quot;Hello&quot;; // Set current instance x variable
        self.y = &quot;Hello&quot;; // Set current instance y variable
    }
}
</code></pre>

<p>To instantiate an inner class of nested classes, you must first instantiate the outer class. However, unlike Java, nested classes in Monkey C do not have access to the members of the enclosing class.</p>

<h2 id="inheritance">Inheritance</h2>

<p>Monkey C uses the <code>extends</code> keyword to support class inheritance:</p>

<pre><code class="java">using Toybox.System as Sys;

class A
{
    function print() {
        Sys.print( &quot;Hello!&quot; );
    }
}

class B extends A
{

}

function usageSample() {
    var inst = new B();
    inst.print();           // Prints &quot;Hello!&quot;
}
</code></pre>

<p>You can call superclass methods by using the super class&#8217;s symbol:</p>

<pre><code class="java">using Toybox.System;

class A
{
    function print() {
        System.print( &quot;Hello!&quot; );
    }
}

class B extends A
{
    function print() {
        // Call the super class implementation
        A.print();

        // Amend the output
        System.println( &quot;Hola!&quot; );
    }
}

function usageSample() {
    var inst = new B();
    inst.print();           // Prints &quot;Hello! Hola!&quot;
}
</code></pre>

<h2 id="datahiding">Data Hiding</h2>

<p>Class members have three levels of access &mdash; <code>public</code>, <code>protected</code>, and <code>private</code>.</p>

<p><code>public</code> is the default, but it can also be explicitly specified. When the <code>public</code> access modifier is used for an enum, variable, or function, those members are visible to all other classes.</p>

<p>The <code>private</code> modifier specifies that the member can only be accessed in its own class.</p>

<p>The <code>protected</code> modifier specifies that the member can only be accessed by its own class or one of its subclasses. The [<code>hidden</code>][^hidden] keyword is synonymous with the <code>protected</code> keyword.</p>

<pre><code class="typescript">class Foo
{
    protected var mVar;
}

function usageSample() {
    var v = new Foo();
    Toybox.System.println( v.mVar ); // Runtime Error
}
</code></pre>

<h2 id="polymorphism">Polymorphism</h2>

<p>Most object-oriented languages support a concept of <em>polymorphic functions</em> in which a function can have multiple definitions based on the input parameter quantity and type. Partially because of its duck-typed nature, Monkey C does not support this kind of runtime polymorphism.</p>

<p>Because function parameters are duck typed, it is possible to implement some level of polymorphism using the <code>instanceof</code> operator:</p>

<pre><code class="typescript">function aPolymorphicFunction(a) {
    switch(a) {
        case instanceof Lang.String:
            return doTheStringVersion(a);
        case instanceof Lang.Number:
        case instanceof Lang.Long:
            return doTheNumericVersion(a);
        default:
            throw new Lang.UnexpectedTypeException();
    }

}
</code></pre>

<p>This kind of pattern works when the function expects the same number of inputs. If your function needs to expect multiple inputs, another pattern is to use the options dictionary. You can use symbols to define the keys to maximize processing efficiency:</p>

<pre><code class="typescript">x = aPolymorphicFunction({
    :param1=&gt;&quot;Foo&quot;,
    :param2=&gt;&quot;Bar&quot;
})
</code></pre>

<p>This pattern is good when you want to leave room for an API to expand in the future.</p>

<h2 id="strongandweakreferences">Strong and Weak References</h2>

<p>Monkey C is reference counted, which means the runtime system will free memory when the number of objects referencing that memory decrements to zero. Reference counting allows memory to become available very quickly which is important in low memory environments. The kryptonite of reference counting are <em>circular references</em>. A circular reference happens when a cycle is formed in the reference chain. For example, imagine object C references object A, object A references object B, <em>and</em> object B references object A.</p>
<figure>
<img src="resources/programmers-guide/weak-reference-1.png" style="max-width:153px;"  role="presentation" />
</figure>

<p>Now C gets invited to sit at the cool-kid table, so it dereferences A so it can hang out with its <em>real</em> friends.<a href="#fn:2" id="fnref:2" title="see footnote" class="footnote">[2]</a></p>
<figure>
<img src="resources/programmers-guide/weak-reference-2.png" style="max-width:153px;" role="presentation" />
</figure>

<p>This forms a roundabout to nowhere. The memory for A and B should be freed at this point, but A and B both have a reference count of one because they reference each other. The memory used by A and B are now unavailable to objects from the cool-kids table.</p>

<p>Sometimes B really does need to reference A. In these cases, you can use a <em>weak reference</em>. A weak reference is an object that keeps a reference to an object but does not increment the reference count. This means the object reference can be destroyed, and is a case that should be handled.</p>
<figure>
<img src="resources/programmers-guide/weak-reference-3.png" style="max-width:153px;" role="presentation" />
</figure>

<p>To create a weak reference you use the <code>weak()</code> method. Weak is a method in <code>Lang.Object</code> and is available to all Monkey C objects.</p>

<pre><code class="java">// I would make a &quot;Hans and Franz&quot; reference but I
// think certain advertising has made them uncool.
var weakRef = obj.weak()
</code></pre>

<p>If you are calling <code>weak</code> on one of the immutable types (<code>Number</code>, <code>Float</code>, <code>Char</code>, <code>Long</code>, <code>Double</code>, <code>String</code>), then it returns the object itself. Otherwise it will return a WeakReference instance.</p>

<pre><code class="typescript">//! A weak reference is a loosely bound reference to
//! another object. If all strong references have been
//! freed, the get() method will return null.
//! This allows the developer to avoid circular references.
//! @since 1.2.0
class WeakReference
{
    //! Return if the reference is still alive.
    //! @return true if object is still alive, false otherwise.
    //!    When you are dead I will be STILL ALIVE
    //!    I feel fantastic and I am STILL ALIVE
    function stillAlive();

    //! Get the object referenced.
    //! @return Object referenced, or null if object is no
    //!         longer alive.
    function get();
}
</code></pre>

<p>You can use the <code>stillAlive</code> method to check if the reference has been cleaned up. Use <code>get</code> to create a strong reference to the object. Only keep the strong reference during the scope you need it!</p>

<pre><code class="java">// This is a triumph...
if( weakRef.stillAlive() ) {
    var strongRef = weakRef.get();
    strongRef.doTheThing();
}
</code></pre>

<h3 id="handlesandheapallocation">Handles and Heap Allocation</h3>

<p>The heap memory limit varies on a per device basis. Starting with version 2.4.x, Connect IQ uses a dynamically allocated heap for memory handles. Each unique object takes up one memory handle. Object references do not have unique allocations and only reference the memory handle of the object. Older versions of Connect IQ have a smaller, static limit for objects defined by the device. Reaching the object limit in either version will cause a runtime error.</p>

<h2 id="modules">Modules</h2>

<p>Modules in Monkey C allow for the scoping of classes and functions. Unlike Java packages, Monkey C modules have many of the same properties as classes. You can have variables, functions, classes, and other modules at the module level:</p>

<pre><code class="java">module MyModule
{
    class Foo
    {
        var mValue;
    }
    var moduleVariable;
}

function usageSample() {
    MyModule.moduleVariable = new MyModule.Foo();
}
</code></pre>

<p>However, unlike classes in Monkey C, modules have no concept of inheritance or data hiding (the <code>extends</code> and <code>hidden</code> keywords are not supported for modules).</p>

<h3 id="usingstatements">Using Statements</h3>

<p>You can bring a module into your scoping level with the <code>using</code> keyword. <code>using</code> allows a module to be imported into another class or module by a symbol:</p>

<pre><code class="java">using Toybox.System;

function foo() {
    System.print( &quot;Hello&quot; );
}
</code></pre>

<p>The <code>as</code> clause provides a way to assign a module to a different name within scope. This is useful for shortening module names or when you simply disagree with our naming scheme<a href="#fn:3" id="fnref:3" title="see footnote" class="footnote">[3]</a>:</p>

<pre><code class="java">using Toybox.System as Sys;

function foo() {
    Sys.print( &quot;Hello&quot; );
}
</code></pre>

<p><code>using</code> statements are scoped to the class or module in which they are defined.</p>

<h2 id="apisandapptypes">APIs and App Types</h2>

<p>The app type defines the user context of an app. Watch faces, for example, have many constraints because they operate in low power mode. To enforce these limits, the Connect IQ Virtual Machine will limit your available APIs based on your app type.</p>

<table>
<colgroup>
<col style="text-align:left;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:left;">Module Name</th>
	<th style="text-align:center;">Data Field</th>
	<th style="text-align:center;">Watch Face</th>
	<th style="text-align:center;">Widget</th>
	<th style="text-align:center;">App</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;">Activity</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">ActivityMonitor*</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">Ant*</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">Application</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">Attention</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">ActivityRecording*</td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">Communications*</td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">FitContributor*</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">Graphics</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">Lang</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">Math</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">PersistedLocations*</td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">Positioning*</td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">Sensor*</td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">Sensor History*</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">System</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">Time</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">Timer</td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">UserProfile*</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
<tr>
	<td style="text-align:left;">WatchUi</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
	<td style="text-align:center;">&#x02713;</td>
</tr>
</tbody>
</table>
<p class="disclaimer">
*Requires app permission<br />
Ant available in data fields and widgets since Connect IQ version 1.2.0
</p>

<p>A Toybox module requested for your app type that is outside this list will result in a <em>Symbol Not Found</em> error.</p>

<h2 id="scoping">Scoping</h2>

<p>Monkey C is a message-passed language. When a function is called, the virtual machine does a look up operation at runtime to find the function being called. Here is the hierarchy that it will search:</p>

<ol>
<li>Instance members of the class</li>
<li>Members of the superclass</li>
<li>Static members of the class</li>
<li>Members of the parent module, and the parent modules up to the global namespace</li>
<li>Members of the superclass&#8217;s parent module up to the global namespace</li>
</ol>

<p>For exmaple, if function <code>a()</code> is called on an instance of <code>Child()</code>, it will be able to access non-member functions <code>b()</code>, <code>c()</code>, and <code>d()</code> when:</p>

<ul>
<li><code>b()</code> is a member of the parent module of the object</li>
<li><code>c()</code> is a static member of the object</li>
<li><code>d()</code> is a member of the parent module of the parent module, also known as the globals module</li>
</ul>

<p>The code below tries to clarify:</p>

<pre><code class="java">using Toybox.System as Sys;

// A globally visible function
function d() {
    Sys.print( &quot;this is D!&quot; );
}

module Parent
{
    // A module function.
    function b() {
        Sys.print( &quot;This is B!&quot; );
        d(); // Call a globally visible function
    }

    // A child class of a Parent module
    class Child
    {
        // An instance method of Child
        function a() {
            Sys.print( &quot;This is A!&quot; );
            b(); // Call a function in our parent module
            c(); // Call a static function within the class.
            d(); // Call a globally visible function.
        }

        // A static function of Child.
        // Note that static methods can't call instance method but still have
        // access to parent modules.
        static function c() {
            Sys.print( &quot;This is C!&quot; );
            b(); // Call a method in the parent module.
            d(); // Call a globally visible function
        }
    }
}
</code></pre>

<p>Sometimes you want to run your search from the global namespace instead of your current scope. You can do this using the bling symbol <code>$</code>. The bling symbol refers to global scope:</p>

<pre><code class="java">function helloFunction() {
    System.println(&quot;Hello Hello&quot;);
}

class A {
     function helloFunction() {
        System.println(&quot;Every time I say goodbye you say hello&quot;);
     }

    function b() {
        // Call global helloFunction
        $.helloFunction();
        // Call instance helloFunction
        helloFunction();
    }
}
</code></pre>

<p>If you are referring to a global variable, using bling can improve runtime performance<a href="#fn:4" id="fnref:4" title="see footnote" class="footnote">[4]</a>:</p>

<pre><code class="java">var globalScopedVariable = &quot;Global String&quot;;

module A
{
    class B
    {
        function c() {
            // To find globalScopedVariable, the VM will search at runtime:
            //     instance B
            //     instance B's superclass Toybox.Lang.Object
            //     Module A
            //     Module A's parent globals
            // and finally find globalScopedVariable.
            System.println(globalScopedVariable);
            // This will search only the global namespace for globalScopedVariable.
            // Thanks bling!
            System.println($.globalScopedVariable);
        }
    }
}
</code></pre>

<p>Because Monkey C is dynamically typed, referencing a global variable will search your Object&#8217;s inheritance structure and the module hierarchy before it will eventually find the global variable. Using the bling symbol we can search globals directly.</p>

<p>Functions are the meat<a href="#fn:5" id="fnref:5" title="see footnote" class="footnote">[5]</a> of your program. Functions define discrete callable units of code.</p>

<p>Monkey C functions can take arguments, but because Monkey C is a dynamically typed language the argument types is not declared; just its name. Also, it is not necessary to declare the return value of a function, or even if a function returns a value, because all functions return values. You can specify the return value with a <code>return</code> statement, but if your function doesn&#8217;t have a <code>return</code> statement it will return the last value on the stack.</p>

<p>Functions can exist in a class or module, or appear in the global module.</p>

<h2 id="variablesexpressionsandoperators">Variables, Expressions, and Operators</h2>

<p>The basic types supported by Monkey C are:</p>

<ul>
<li><strong>Integers</strong> - 32-bit signed integers</li>
<li><strong>Floats</strong> - 32-bit floating point numbers</li>
<li><strong>Longs</strong> – 64-bit signed integers</li>
<li><strong>Doubles</strong> – 64-bit floating point numbers</li>
<li><strong>Booleans</strong> - <code>true</code> and <code>false</code></li>
<li><strong>Chars</strong> - Unicode characters</li>
<li><strong>Strings</strong> - strings of characters</li>
<li><strong>Objects</strong> – Instantiated objects (defined with the class keyword)</li>
<li><strong>Arrays</strong> - Allocated with the syntax <code>new [X]</code> where &#8216;X&#8217; is an expression computing the size of the array</li>
<li><strong>Dictionaries</strong> - Associative arrays, allocated with the syntax <code>{}</code></li>
</ul>

<h3 id="keywords">Keywords</h3>

<p>Here is a list of keywords in the Monkey C programming language. You cannot use any of the following as variables or symbols in your programs. The keyword <code>native</code> is reserved, even though it is not currently used. <code>true</code>, <code>false</code>, <code>null</code>, <code>NaN</code>, <code>new</code>, <code>and</code>, and <code>or</code> might seem like keywords, but they are actually literals and operators; you cannot use them as identifiers in your programs.</p>
<div id="test">

<table>
<colgroup>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
</colgroup>

<tbody>
<tr>
	<td style="text-align:center;">as</td>
	<td style="text-align:center;">const</td>
	<td style="text-align:center;">enum</td>
	<td style="text-align:center;">has</td>
	<td style="text-align:center;">module</td>
	<td style="text-align:center;">self</td>
	<td style="text-align:center;">using</td>
</tr>
<tr>
	<td style="text-align:center;">break</td>
	<td style="text-align:center;">continue</td>
	<td style="text-align:center;">extends</td>
	<td style="text-align:center;">hidden</td>
	<td style="text-align:center;">private</td>
	<td style="text-align:center;">static</td>
	<td style="text-align:center;">var</td>
</tr>
<tr>
	<td style="text-align:center;">case</td>
	<td style="text-align:center;">default</td>
	<td style="text-align:center;">finally</td>
	<td style="text-align:center;">if</td>
	<td style="text-align:center;">protected</td>
	<td style="text-align:center;">switch</td>
	<td style="text-align:center;">while</td>
</tr>
<tr>
	<td style="text-align:center;">catch</td>
	<td style="text-align:center;">do</td>
	<td style="text-align:center;">for</td>
	<td style="text-align:center;">instanceof</td>
	<td style="text-align:center;">public</td>
	<td style="text-align:center;">throw</td>
</tr>
<tr>
	<td style="text-align:center;">class</td>
	<td style="text-align:center;">else</td>
	<td style="text-align:center;">function</td>
	<td style="text-align:center;">me</td>
	<td style="text-align:center;">return</td>
	<td style="text-align:center;">try</td>
</tr>
</tbody>
</table>
</div>

<h3 id="declaringvariables">Declaring Variables</h3>

<p>All local variables must be declared ahead of time using the <code>var</code> keyword. In the Monkey C language, all values (including numeric values) are objects.</p>

<pre><code class="java">var n = null;               // Null reference
var x = 5;                  // 32-bit signed integers
var y = 6.0;                // 32-bit floating point
var l = 5l;                 // 64-bit signed integers
var d = 4.0d;               // 64-bit floating point
var bool = true;            // Boolean (true or false)
var c = 'x';                // Unicode character
var str = &quot;Hello&quot;;          // String
var arr = new [20 + 30];    // Array of size 50
var dict = { x=&gt;y };        // Dictionary: key is 5, value is 6.0
var z = arr[2] + x;         // Null pointer waiting to happen
</code></pre>

<p>Monkey C supports the following operators:</p>
<div id="operators">

<table>
<colgroup>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:center;">Precedence</th>
	<th style="text-align:center;">Operator</th>
	<th style="text-align:left;">Description</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:center;">1</td>
	<td style="text-align:center;"><code>new</code></td>
	<td style="text-align:left;">creation</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>!</code></td>
	<td style="text-align:left;">logical NOT</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>~</code></td>
	<td style="text-align:left;">bitwise NOT</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>( )</code></td>
	<td style="text-align:left;">function invocation</td>
</tr>
<tr>
	<td style="text-align:center;">2</td>
	<td style="text-align:center;"><code>*</code></td>
	<td style="text-align:left;">multiplication</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>/</code></td>
	<td style="text-align:left;">division</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>%</code></td>
	<td style="text-align:left;">modulo</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>&amp;</code></td>
	<td style="text-align:left;">bitwise AND</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>&lt;&lt;</code></td>
	<td style="text-align:left;">left shift</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>&gt;&gt;</code></td>
	<td style="text-align:left;">right shift</td>
</tr>
<tr>
	<td style="text-align:center;">3</td>
	<td style="text-align:center;"><code>+</code></td>
	<td style="text-align:left;">addition</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>-</code></td>
	<td style="text-align:left;">subtraction</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>|</code></td>
	<td style="text-align:left;">bitwise OR</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>^</code></td>
	<td style="text-align:left;">bitwise XOR</td>
</tr>
<tr>
	<td style="text-align:center;">4</td>
	<td style="text-align:center;"><code>&lt;</code></td>
	<td style="text-align:left;">less than</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>&lt;=</code></td>
	<td style="text-align:left;">less than or equals</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>&gt;</code></td>
	<td style="text-align:left;">greater than</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>&gt;=</code></td>
	<td style="text-align:left;">greater than or equals</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>==</code></td>
	<td style="text-align:left;">equals</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>!=</code></td>
	<td style="text-align:left;">not equals</td>
</tr>
<tr>
	<td style="text-align:center;">5</td>
	<td style="text-align:center;"><code>&amp;&amp;</code></td>
	<td style="text-align:left;">logical AND</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>and</code></td>
	<td style="text-align:left;"></td>
</tr>
<tr>
	<td style="text-align:center;">6</td>
	<td style="text-align:center;"><code>||</code></td>
	<td style="text-align:left;">logical OR</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>or</code></td>
	<td style="text-align:left;"></td>
</tr>
</tbody>
</table>
</div>

<h3 id="symbols">Symbols</h3>

<p>Symbols are lightweight constant identifiers. When the Monkey C compiler finds a new symbol, it will assign it a new unique value. This allows symbols to be used as keys or constants without explicitly declaring a const or enum:</p>

<pre><code class="java">var a = :symbol_1;
var b = :symbol_1;
var c = :symbol_2;
Sys.println( a == b );  // Prints true
Sys.println( a == c );  // Prints false
</code></pre>

<p>Symbols can be useful when wanting to create keys without having to declare an enum:</p>

<pre><code class="java">var person = { :firstName=&gt;&quot;Bob&quot;, :lastName=&gt;&quot;Jones&quot; };
</code></pre>

<h3 id="constants">Constants</h3>

<p>Constants are named, immutable values declared with the <code>const</code> keyword. These are useful for storing unchanging values that may be used repeatedly throughout code. Constants must be declared at the module or class level; they cannot be declared within a function.</p>

<p>Constants support the same types as <a href="#declaringvariables">listed for variables</a>. It is important to note that with data structures like arrays, <code>const</code> functions similar to Java&#8217;s <code>final</code> keyword. For example, a <code>const</code> array prevents the array from being replaced by a new instance, but the elements of the array may be modified.</p>

<pre><code class="java">const PI = 3.14;
const EAT_BANANAS = true;
const BANANA_YELLOW = &quot;#FFE135&quot;;
</code></pre>

<h3 id="enumerations">Enumerations</h3>

<p>Enumerations are explicit or auto-incrementing constant mappings from symbol to integer. Unless explicity set (see the second example), each proceeding symbol is automatically assigned the value of its predecessor plus one, starting with <code>0</code>. So, in the following example, the symbol Monday is automatically assigned the value <code>0</code>, Tuesday is assigned <code>1</code>, and so on. These symbols can be used just like constant variables (which is essentially what they are). Enums must be declared at the module or class level; they cannot be declared within a function.</p>

<pre><code class="java">enum {
    Monday,   // Monday = 0
    Tuesday,  // Tuesday = 1
    Wednesday // Wednesday = 2
    // ...and so on
}
</code></pre>

<pre><code class="java">enum {
    x = 1337, // x = 1337
    y,        // y = 1338
    z,        // z = 1339
    a = 0,    // a = 0
    b,        // b = 1
    c         // c = 2
}
</code></pre>

<p>Note that assigning anything other than an integer will cause an error.</p>

<h3 id="callingmethodsandfunctions">Calling Methods and Functions</h3>

<p>To call a method within your own class or module, simply use the function call syntax:</p>

<pre><code class="typescript">function foo( a ) {
    //Assume foo does something really impressive
}

function bar() {
    foo( &quot;hello&quot; );
}
</code></pre>

<p>If calling on an instance of an object, precede the call with the object and a &#8216;<code>.</code>&#8217;.</p>

<p>When accessing class members, <code>public</code> and <code>protected</code> variables should be accessed using either one of the following formats:</p>

<pre><code class="typescript">var x = mMemberVariable;
var y = self.mMemberVariable;
</code></pre>

<p>Overridden parent member functions should be accessed using the following syntax:</p>

<pre><code class="typescript">class A
{
    function overridableMethod() {
        System.println(&quot;I am A!&quot;);
    }
}

class B extends A
{
    function overridableMethod() {
        System.println(&quot;B wins!&quot;);
        A.overridableMethod();
    }
}
</code></pre>

<p>The syntax of &#8220;SuperClass.memberVariable&#8221; is not supported in the Monkey C language. Always use <code>self</code> to access member variables of super classes.</p>

<h3 id="ifstatements">If Statements</h3>

<p><code>if</code> statements allow branch points in your code:</p>

<pre><code class="java">myInstance.methodToCall( parameter );

if ( a == true ) {
    // Do something
} else if ( b == true ) {
    // Do something else
} else {
    // If all else fails
}

// Monkey C also supports the ternary operator
var result = a ? 1 : 2;
</code></pre>

<p>The expression inside the <code>if</code> statement is required to be an expression; assignments are not allowed. Things that will evaluate to true are:</p>

<ul>
<li><code>true</code></li>
<li>A non-zero integer</li>
<li>A non-null object</li>
</ul>

<h3 id="switchstatements">Switch Statements</h3>

<p>Like <code>if</code> statements, <code>switch</code> statements also allow branch points in your code. Deciding whether to use <code>if</code> statements or a <code>switch</code> statement is based on readability and the expression that the statement is testing.</p>

<p>A <code>switch</code> statement tests expressions based only on a single object. Like <code>if</code> statements, the expression inside the <code>switch</code> statement is required to be an expression; assignments are not allowed. You can have any number of <code>case</code> statements within a <code>switch</code> statement. Each <code>case</code> is followed by the object or <code>instanceof</code> object to be compared to and a colon:</p>

<pre><code class="typescript">switch ( obj ) {
    case true:
    // Do something
    break;
    case 1:
    // Do something
    break;
    case &quot;B&quot;: {
        // Do something
        break;
    }
    // Executed based on the type
    // instead of the value
    case instanceof MyClass:
    // Do something
    break;
    default:
    // If all else fails
    break;
}

// Monkey C also supports fall-through into the next case statement
switch ( obj ) {
    case false:
    // Do something
    // Fall through and execute the code in the next case block
    case 2: {
        // Do something
        break;
    }
    case instanceof MyOtherClass:
    // Do something
    break;
    case &quot;B&quot;:
    // Do something
    // Fall through and execute the code in the default block
    default:
    // If all else fails
    break;
}
</code></pre>

<p>The <code>instanceof</code> operator is discussed in more detail later in this guide.</p>

<p>When the object being switched on is either equal to or an instance of the value defined in a <code>case</code> statement, the statements following that <code>case</code> will execute until a <code>break</code> statement is reached. Each <code>break</code> statement terminates the enclosing <code>switch</code> statement. Without a <code>break</code> statement, <code>case</code> statements fall through: all statements after the matching <code>case</code> label are executed in sequence, regardless of the expression of the subsequent <code>case</code> labels, until a <code>break</code> statement is encountered. A final <code>break</code> statement is not required because control flow will just naturally fall out of the <code>switch</code> statement.</p>

<p>A <code>switch</code> statement can also have a single optional <code>default</code> case, which is not required to appear at the end of the <code>switch</code> statement. The <code>default</code> case handles all objects that are not explicitly handled by one of the <code>case</code> statements.</p>

<h3 id="switchblockvariablescoping">Switch Block Variable Scoping</h3>

<p>The body of a <code>switch</code> statement is known as the &#8220;switch block&#8221;. Variables declared within the switch block will be scoped at the switch block level. Variables defined within curly braces of a case block will be scoped at that code block level. Additionally, due to the nature of fall-through cases, all variables defined at the switch block level must be initialized before being used in any subsequent <code>case</code> statements. For instance:</p>

<pre><code class="java">switch ( obj ) {
    case true:
    var aaa = 1; // Scoped at the switch block level
    ...
    case 1:
    var zzz = aaa; // Results in a compiler error because aaa was not initialized in this case block
    ...
    break;
    case &quot;B&quot;: {
       var aaa = true; // Scoped at the code block level within the curly braces, no scoping conflict with variable aaa at the swtich block level
       ...
       break;
    }
    case instanceof MyClass:
    var aaa = &quot;Hello!&quot; // Results in a compiler error because aaa has already been defined in the switch block
    ...
    default:
    aaa = 0; // aaa was defined in the first case and initialized at the beginning of the default case, no errors!
    var good = aaa;
    ...
    break;
}
</code></pre>

<h3 id="loops">Loops</h3>

<p>Monkey C supports <code>for</code> loops, <code>while</code> loops, and <code>do/while</code> loops. <code>while</code> and <code>do/while</code> loops have a familiar syntax:</p>

<pre><code class="java">// do/while loop
do {
    // Code to do in a loop
}
while( expression );

// while loop
while( expression ) {
    // Code to do in a loop
}
</code></pre>

<p>Loops must have braces around them because single-line loops are not supported:</p>

<pre><code class="java">// Monkey C does allow for variable declaration in for loops
for( var i = 0; i &lt; array.size(); i++ ) {
    // Code to do in a loop
}
</code></pre>

<p>Control within loops can be managed by using the <code>break</code> and <code>continue</code> statements. These should also have familiar behavior:</p>

<pre><code class="java">// This for loop should only print 5, 6, and 7.
for (var i = 0; i &lt; 10; i += 1) {
    if (i &lt; 5) {
        continue;
    }
    System.println(i);
    if (7 == i) {
        break;
    }
}
</code></pre>

<h3 id="returningvaluesfromfunctions">Returning Values From Functions</h3>

<p>All functions return values in Monkey C. You can explicitly set the return value by using the <code>return</code> keyword:</p>

<pre><code class="java">return expression;
</code></pre>

<p>The expression is optional. Functions without a return statement automatically return the last value operated on.</p>

<h3 id="instanceofandhas">Instanceof and Has</h3>

<p>As a duck-typed language, Monkey C gives the programmer great flexibility, but the trade off is that the compiler cannot perform the type checking like in C, C++ or Java. Monkey C provides two tools to do runtime type checking&mdash;<code>instanceof</code> and <code>has</code>.</p>

<p>The <code>instanceof</code> operator offers the ability to check if an object instance inherits from a given class. The second argument is the class name to check against:</p>

<pre><code class="java">var value = 5;
// Check to see if value is a number
if ( value instanceof Toybox.Lang.Number )
{
    System.println( &quot;Value is a number&quot; );
}
</code></pre>

<p>The <code>has</code> operator lets you check if a given object has a symbol, which may be a public method, instance variable, or even a class definition or module. The second argument is the symbol to check for. For example, assume we have magnetometer libraries in <code>Toybox.Sensor.Magnetometer</code>, but not all products have a magnetometer. Here is an example of changing your implementation based on those criteria:</p>

<pre><code class="java">var impl;
// Check to see if the Magnetometer module exists in Toybox
if ( Toybox has :Magnetometer )
{
    impl = new ImplementationWithMagnetometer();
}
else
{
    impl = new ImplementationWithoutMagnetometer();
}
</code></pre>

<p>Monkey C&#8217;s object-oriented design patterns in conjunction with the <code>has</code> and <code>instanceof</code> operator enables software that has implementations for many devices in one code base.</p>

<h2 id="callbacks">Callbacks</h2>

<p>Functions in Monkey C are not first class, meaning you cannot pass them as objects directly for use in other functions. However, using the <code>method()</code> function inherited from <code>Toybox.Lang.Object</code>, a class instance can create a <code>Method</code> object, which provides a way to invoke it as a callback method.</p>

<pre><code class="java">class Foo
{
    function operation(a, b) {
        // The code here is really amazing. Like mind blowing amazing. You wish this method was in your program.
    }
}
function usageSample() {
    // Create a new instance of Foo
    var v = new Foo();
    // Get the callback for the operation method from the instance of Foo.
    var m = v.method(:operation);
    // Invoke v's operation method.
    m.invoke(1,2);
}
</code></pre>

<p>A<code>Method</code> object will invoke a method on the instance of the object it came from. It keeps a strong reference to the source object.</p>

<p>Unlike classes, Modules do not inherit from Object so do not have access to the <code>method()</code> function. However, a new instance of <code>Method</code> can be created, which allows module-level functions to be invoked as callbacks in a similar fashion:</p>

<pre><code class="typescript">using Toybox.Lang as Lang;

module Foo
{
    function operation() {
        // Do something
    }
}
function moduleSample() {
    var v = new Lang.Method(Foo, :operation);
    v.invoke();
}
</code></pre>

<h1 id="containers">Containers</h1>

<p>Monkey C has two container types built into the language: Arrays and Dictionaries.</p>

<h2 id="arrays">Arrays</h2>

<p>Arrays in Monkey C, like variables, are typeless, it is not necessary to declare a data type. There are two forms for creating a new array. To create an empty array of a fixed <code>size</code>, use this:</p>

<pre><code class="java">var array = new [size];
</code></pre>

<p>To pre-initialize an array, this syntax can be used:</p>

<pre><code class="java">var array = [1, 2, 3, 4, 5];
</code></pre>

<p>Elements are expressions, so multidimensional arrays can be created using this syntax:</p>

<pre><code class="java">var array = [ [1,2], [3,4] ];
</code></pre>

<p>Monkey C does not have a direct way of creating an empty two-dimensional array, one may be initialized with this syntax:</p>

<pre><code class="java">// Shout out to all the Java programmers in the house
var array = new [first_dimension_size];

// Initialize the sub-arrays
for( var i = 0; i &lt; first_dimension_size; i += 1 ) {
    array[i] = new [second_dimension_size];
}
</code></pre>

<h2 id="dictionaries">Dictionaries</h2>

<p>Dictionaries, or associative arrays, are a built-in data structure in Monkey C:</p>

<pre><code class="java">var dict = { &quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2 };  // Creates a dictionary
System.println( dict[&quot;a&quot;] );        // Prints &quot;1&quot;
System.println( dict[&quot;b&quot;] );        // Prints &quot;2&quot;
System.println( dict[&quot;c&quot;] );        // Prints &quot;null&quot;
</code></pre>

<p>To initialize an empty dictionary, use the following syntax:</p>

<pre><code class="java">var x = {};                         // Empty dictionary
</code></pre>

<p>By default, objects hash on their reference value. Classes should override the <code>hashCode()</code> method in <code>Toybox.Lang.Object</code> to change the hashing function for their type:</p>

<pre><code class="java">class Person
{
    // Return a number as the hash code. Remember that the hash code must be
    // the same for two objects that are equal.
    // @return Hash code value
    function hashCode() {
        // Using the unique person id for the hash code
        return mPersonId;
    }
}
</code></pre>

<p>Dictionaries automatically resize and rehash as the contents grow or shrink. This makes them extremely flexible, but it comes at a cost. Insertion and removal of the contents can cause performance problems if there is accidental or excessive resizing and rehashing. Also, because hash tables require extra space for allocation, they are not as space-efficient as either objects or arrays.</p>

<h1 id="exceptionsanderrors">Exceptions and Errors</h1>

<p>Monkey C supports structured exception handling for non-fatal errors from which there can be recovery. The syntax should be familiar for Java and Javascript developers:</p>

<pre><code class="java">try {
    // Code to execute
}
catch( ex instanceof AnExceptionClass ) {
    // Code to handle the throw of AnExceptionClass
}
catch( ex ) {
    // Code to catch all execeptions
}
finally {
    // Code to execute when
}
</code></pre>

<p>You can use the <code>throw</code> keyword to throw an exception.</p>

<h2 id="creatinganexception">Creating an Exception</h2>

<p>If you are creating your own exception, follow these rules:</p>

<ul>
<li>Extend <code>Toybox.Lang.Exception</code></li>
<li>Initialize the superclass in the initializer</li>
<li>Assign a string message to the <code>mMessage</code> member variable</li>
</ul>

<p>For example, an app specific exception can be defined as follows:</p>

<pre><code class="typescript">class AppSpecificException extends Lang.Exception {
    //! Constructor
    //! @param msg Message explaining cause
    function initialize(msg) {
        Exception.initialize();
        self.mMessage = msg;
    }
}
</code></pre>

<h2 id="errors">Errors</h2>

<p>Because Monkey C uses dynamic typing, there are many errors for which the compiler cannot check. If the error is of high enough severity, it will raise an fatal API error and cause your app to terminate at runtime. These errors cannot be caught.</p>

<dl>
<dt>Array Out Of Bounds</dt>
<dd>An attempt is being made to reference an array outside of its allocated bounds</dd>

<dt>Circular Dependency</dt>
<dd>There is a loop in the dependency graph of a module or object that prevents a module or object from being constructed</dd>

<dt>Communications Error</dt>
<dd>An error has occurred in <a href="https://en.wikipedia.org/wiki/Bluetooth_low_energy" title="Bluetooth low energy">BLE</a> communications</dd>

<dt>File Not Found</dt>
<dd>The app file could not be found, which is usually caused when trying to load a resource from the app file</dd>

<dt>Illegal Frame</dt>
<dd>The return address on the stack is corrupted</dd>

<dt>Initializer Error</dt>
<dd>An error occurred in an initializer</dd>

<dt>Invalid Value</dt>
<dd>An argument passed to a function or method is invalid</dd>

<dt>Null Reference</dt>
<dd>A value is being requested from a null value</dd>

<dt>Out of Memory</dt>
<dd>Indicates no more system memory is available for allocation</dd>

<dt>Permission Required</dt>
<dd>An attempt was made to use a restricted API without permission</dd>

<dt>Stack Underflow</dt>
<dd>The stack pointer went past the bottom of the stack memory limit</dd>

<dt>Stack Overflow</dt>
<dd>The stack pointer went past the top of the stack memory limit</dd>

<dt>Symbol Not Found</dt>
<dd>An attempt was made to access a variable or method that does not exist in the specified object or method</dd>

<dt>System Error</dt>
<dd>A generic error used by the Toybox APIs for fatal errors</dd>

<dt>Too Many Arguments</dt>
<dd>Too many arguments used by a method, which are currently limited to 10 arguments</dd>

<dt>Too Many Timers</dt>
<dd>Too many <code>Timer::Timer</code> objects for the target device were started</dd>

<dt>Unexpected Type</dt>
<dd>Indicates an operation being done on a variable that is unsupported by the type; for example, trying to perform a bitwise OR on two string</dd>

<dt>Unhandled Exception</dt>
<dd>An <code>Exception</code> was thrown but was not caught by an exception handler</dd>

<dt>Watchdog Tripped</dt>
<dd>A Monkey C function has executed for too long; watchdogs prevent a Monkey C program from hanging the system via an infinite loop</dd>
</dl>

<h1 id="annotations">Annotations</h1>

<p>Monkey C allows associating symbols with class or module methods and variables. These symbols are currently written into the <code>debug.xml</code> file generated by the compiler, but may be used in the future to add new features without changing the Monkey C grammar:</p>

<pre><code class="java">(:debug) class TestMethods
{
    (:test) static function testThisClass( x )
}
</code></pre>

<p>The following annotations have special meanings to the Monkey C compiler:</p>

<dl>
<dt><strong>:background</strong> <!-- The bold delimiter is required here because there's no way to escape the leading ':' in MMD --></dt>
<dd>Denotes code blocks available to the Background process.</dd>

<dt><strong>:debug</strong></dt>
<dd>Code blocks decorated with this annotation will not be included in release builds at compile time.</dd>

<dt><strong>:release</strong></dt>
<dd>Code blocks decorated with this annotation will not be included in debug builds at compile time.</dd>

<dt><strong>:test</strong></dt>
<dd>Denotes test cases that are used as Run No Evil unit tests and are excluded from the application at compile time.</dd>

<dt><strong>:glance</strong></dt>
<dd>
<p>Denotes code blocks available to when running in Glance Mode.</p>

<h1 id="codingconventions">Coding Conventions</h1></dd>
</dl>

<p>Here are guidelines for Monkey C code:</p>

<h2 id="naming">Naming</h2>

<ul>
<li>Modules and Classes are camel-cased with the first letter in upper case.</li>
<li>Functions are camel-cased with the first letter always being lower case.</li>
<li>Private class member variables are camel cased with the first character being an underscore (_) and then the first letter lower case.</li>
<li>Public class member variables are camel cased with the first letter lower case.</li>
<li>Module variables should be camel cased with a lower cased first letter</li>
<li>Enums must have a common prefix, e.g. <em>COLOR_RED</em>, <em>COLOR_BLUE</em>.</li>
<li>In POMO (Plain Old Monkey C Objects) it is okay to have all public members.</li>
</ul>

<h2 id="source">Source</h2>

<ul>
<li>Put one class per Monkey C source file.</li>
<li>Monkey C code should use spaces aligned four spaces per indent level. The Monkey C editor will automatically convert spaces to tabs and remove trailing white space.</li>
<li>When defining modules, classes, functions, and enums, put the opening brace on the same line as the definition and the closing brace aligned with the first character as the definition.</li>
</ul>

<h2 id="definitions">Definitions</h2>

<ul>
<li>Avoid pure global variables when possible.</li>
<li>Because modules are not purely lexical and have runtime memory cost, putting class definitions into the global module is acceptable.</li>
<li>Avoid having public static members in class definitions; instead move those definitions into the parent module.</li>
<li>In the first line of your class initialize function, always call the superclass initialize.</li>
</ul>

<h2 id="sample">Sample</h2>

<p>Here is a sample:</p>

<pre><code class="C++">class SampleName extends Toybox.Application.AppBase
{
    public var publicVar;
    private var _privateVar;

    function initialize() {
        AppBase.initialize();
    }
    // onStart() is called on application start up
    function onStart(state) {
    }

    // onStop() is called when your application is exiting
    function onStop(state) {
    }

    // Return the initial view of your application here
    function getInitialView(){
        return [new SampleNameView(), new SampleNameDelegate()];
    }
 }
</code></pre>

<h1 id="monkeytypescomingsoon">Monkey Types (COMING SOON)</h1>

<p>Connect IQ 4.0 introduces Monkey Types, a gradual type system for the Monkey C language. The type system is designed to recognize Monkey C&#8217;s historically duck-typed nature but add the necessary components to type check your applications at compile time.</p>

<p>Monkey Types has the following goals:</p>

<ol>
<li><strong>Compatibility</strong> - Breaking changes to the Monkey C language would require re-work to thousands of Connect IQ apps. Monkey Types extends the Monkey C grammar but avoids breaking changes. Monkey Types is also designed to not rely on additional run time information. Because of this you can use Monkey Types for apps that run on Connect IQ 1.x compatible devices.</li>
<li><strong>Ease of Use</strong> - The philosophy of Monkey C is to be <em>the language you didn&#8217;t know you already knew</em>. We want the experience of writing Monkey C to be like deja-vu. Likewise, Monkey Types borrows heavily from Kotlin, Swift, and Typescript in its design.</li>
<li><strong>Flexibility</strong> - Monkey Types is a gradual type system. You can leave the type scaffolding off if you choose, or you can strictly type your app.</li>
</ol>

<h2 id="theimportstatement">The import Statement</h2>

<p>In traditional Monkey C, the <code>using</code> statement brings a <code>module</code> suffix into the namespace of the file being processed. To access any functions, variables, or class definitions, the module suffix must be referenced.</p>

<pre><code class="typescript">using FrereJacques;

function morning() {
    var brotherJohn = new FrereJacques.BrotherJohn();
    if(brotherJohn.isSleeping()) {
        brotherJohn.wake();
    }
    FrereJacques.ring(:morningBells);
}
</code></pre>

<p>Monkey Types introduces the <code>import</code> statement. When you use <code>import</code> it will bring the <em>module suffix and all classes in the module into the file namespace</em>. This allows classes in a module to be accessed without the module suffix, making for easier typing. Functions still require the module suffix to be accessed.</p>

<pre><code class="typescript">import FrereJacques;

function morning() {
    // No longer need the module prefix on new
    var brotherJohn = new BrotherJohn();
    if(brotherJohn.isSleeping()) {
        brotherJohn.wake();
    }
    // Still need module prefix on calls to
    // module functions
    FrereJacques.ring(:morningBells);
}
</code></pre>

<h2 id="theasclause">The as Clause</h2>

<p>Monkey Types introduces a new keyword <code>as</code>. You use <code>as</code> to bind a type to a local variable, member variable, module variable, function argument, or function return value. Once a type has been bound to a value, the compiler will only allow values of that type to be assigned.</p>

<pre><code class="typescript">import Toybox.Lang;

function hasANumber() {
    var x as Number = 0;

    x = 2;  // Allowed
    x = &quot;2&quot;; // Not allowed
}
</code></pre>

<p>In the function <code>hasANumber</code>, we are declaring that local variable <code>x</code> will only accept values of <code>Toybox.Lang.Number</code>. Once that has been declared, the compiler will only allow values of that type to be assigned to <code>x</code>.</p>

<p>Since Monkey C is a duck typed language, only allowing a single type to be bound to a variable would be overly restrictive. An <code>as</code> clause is allowed to have an <code>or</code> clause attached if a variable accepts multiple types.</p>

<pre><code class="typescript">import Toybox.Lang;

function hasANumber() {
    var x as Number or String = 0;

    x = 2;  // Allowed
    x = &quot;2&quot;; // Allowed
}
</code></pre>

<h2 id="namedversusanonymoustypes">Named Versus Anonymous Types</h2>

<p>As you can see from the above example, the type system can allow for complicated type definitions. There are times where a type pattern is repeated that you just want to refer to it by a name.</p>

<p>A <code>typedef</code> statement allows you to create a <em>named type</em> in the application namespace. For example, the following would create a poly type named <code>Numeric</code> in the global namespace. The function <code>add</code> then binds <code>Numeric</code> to parameters <code>a</code> and <code>b</code> and its return value by having the <code>as</code> clauses refer to the <code>Numeric</code> type declaration.</p>

<pre><code class="typescript">import Toybox.Lang;

typedef Numeric as Number or Float or Long or Double;

function add(a as Numeric, b as Numeric) as Numeric {
    return a + b;
}
</code></pre>

<p>If you do not wish to name your type declarations, you can always use the <code>as</code> clause to build the type declaration in line as an anonymous type.</p>

<h2 id="types">Types</h2>

<p>Monkey Types allows you to add a layer of type scaffolding to your Monkey C code. The type system allows for a lot more than associating variables with classes.</p>

<p>This section will overview the type declarations you can use.</p>

<h3 id="any">Any</h3>

<p>Any variable, function argument, or function return value that does not have a type bound to it is of type Any. The Any type can be anything, including nothing. Values of type Any follow the traditional duck type rules of Monkey C.</p>

<p>To bind Any to a value, simply do not add an <code>as</code> clause to it&#8217;s declaration. There is no keyword to bind Any to a value.</p>

<h3 id="void">Void</h3>

<p>The void type is only for return values, and communicates that a function does not allow return values. It also communicates that a function should not expect a return value by calling this function.</p>

<pre><code class="typescript">import Toybox.Lang;

function doNothing() as Void {
    // Compiler error - this is failing to
    // do nothing.
    return true;
}

function doSomething() as String {
    // Compiler error - cannot assign value
    // from a function that returns nothing
    var x = doNothing();
}
</code></pre>

<h3 id="concrete">Concrete</h3>

<p>Concrete types refer to a class in the program namespace. If a value is bound to a concrete type, it will accept values of that class or any derived classes.</p>

<pre><code class="typescript">import Toybox.Lang;
import WoolMarket;

class Wool {
    public var bagsFull;

    public function initialize(bags as Number) {
        bagsFull = bags;
    }
}

class Sheep {
    public var wool as Wool;

    public function initialize() {
        wool = new Wool(1);
    }
}

class BlackSheep extends Sheep {
    public function initialize() {
        Sheep.initialize();
        wool = new Wool(3);
    }
}

function processSheep(baa as Sheep) {
    if(baa.wool != null) {
        WoolMarket.sellWool(baa.wool);
    }
}

function example() {
    // Allowed
    processSheep(new Sheep());
    processSheep(new BlackSheep());
    // Not allowed
    processSheep(new Wool());
}
</code></pre>

<h3 id="poly">Poly</h3>

<p>Poly types allow the concatenation or multiple types into a single type. This allows for the type system to model the duck-type nature of Monkey C. To create a poly type, you simply use the <code>or</code> clause when defining your type.</p>

<p>A poly type will accept:</p>

<ol>
<li>A value whose type is bound to one of the types within the poly type</li>
<li>A value bound to a poly type whose types are within the definition of the destination type</li>
</ol>

<pre><code class="typescript">import Toybox.Lang;

typedef Addable as Number or Float or Long or Double or String;
typedef Numeric as Number or Float or Long or Double;

function add(a as Addable, b as Addable) as Addable {
    return a + b;
}

function subtract(a as Numeric, b as Numeric) as Numeric {
    return a - b;
}

function doWork() {
    // Allowed
    var x as Addable = add(&quot;1&quot;, &quot;2&quot;);
    // Not allowed; Addable has String which is
    // not within Numeric
    var y as Numeric = subtract(x, 2);
}
</code></pre>

<h3 id="interface">Interface</h3>

<p>An interface type requires a class to contain a set of member declarations. The members can be member variables and functions.</p>

<pre><code class="typescript">import Toybox.Lang;

typedef LittleBoys as interface {
    var frogs as Array&lt;Frogs&gt;;
    var snails as Array&lt;Snails&gt;;
    var puppyDogTails as Array&lt;PuppyDogTails&gt;;
}

// Implements LittleBoys interface
class MaleChild {
    var frogs as Array&lt;Frogs&gt;;
    var snails as Array&lt;Snails&gt;;
    var puppyDogTails as Array&lt;PuppyDogTails&gt;;
}
</code></pre>

<p>Note that the class does not require additional decoration to implement the interface. This allows anonymous interfaces to be defined within function arguments.</p>

<pre><code class="typescript">// Processing
function example(you as interface {
    var frogs as Array&lt;Frogs&gt;;
})
</code></pre>

<h3 id="container">Container</h3>

<p>The Monkey C language has two native container types, <code>Array</code> and <code>Dictionary</code>. While the Monkey Types system does not support generics, it does allow for the developer to type the value type of an <code>Array</code> or the key and value type of a <code>Dictionary</code>.</p>

<pre><code class="typescript">import Toybox.Lang;

typedef ContainerA as Array&lt;Number&gt;;
typedef ContainerB as Dictionary&lt;String, Number&gt;;
</code></pre>

<p>Container types only match other container types if both the key and value types exactly match.</p>

<h3 id="dictionary">Dictionary</h3>

<p>A common pattern in Monkey C is to use an options dictionary as an argument. This allows for extensible APIs. Monkey Types allows modeling an options dictionary by binding key literals to types.</p>

<pre><code class="typescript">import Toybox.Lang;

function doWork(options as {
    :option1 as String,
    :option2 as {
        &quot;name&quot; as String,
        &quot;value&quot; as Number
    }
})
</code></pre>

<p>If a dictionary is declared inline, the compiler will track the types bound to the values, and then type check to see if all the value types match. It will not require all keys to be provided, and it will not error if additional keys are added.</p>

<pre><code class="typescript">doWork({:option1=&gt;&quot;x&quot;, :option3=&gt;true})
</code></pre>

<h3 id="enumerations">Enumerations</h3>

<p>Enumerations can now be named types by appending a name to the declaration. Enumeration values will be bound to both their enumeration type as well as their value type.</p>

<pre><code class="typescript">import Toybox.Lang;

enum Dog {
    SPOT = &quot;Spot&quot;,
    LUKE = &quot;Luke&quot;,
    POCO = &quot;Poco&quot;,
    COMMODORE = &quot;Commodore&quot;,
    BINGO = &quot;B_I_N_G_O&quot;
}

function getDogName(dog as Dog) as String {
    // Return the dog name
    return dog.toString();
}
</code></pre>

<h3 id="callback">Callback</h3>

<p>The base object of Monkey C has the <code>method</code> to create callback objects. The callback type allows you to model a <code>Method</code> object.</p>

<pre><code class="typescript">import Toybox.Lang;

function doWork(
    x as Method(a as Number) as String
) as String {
    return x.invoke(2);
}
</code></pre>

<h3 id="null">Null</h3>

<p>Monkey Types treats Null as its own unique type. More importantly, Monkey Types requires explicit declaration if <code>null</code> is an allowed value.</p>

<pre><code class="typescript">function doWork() as Number or Null
</code></pre>

<p>The <code>?</code> can be used with single type declarations to make it a null accepting poly type.</p>

<pre><code class="typescript">function doWork() as Number?
</code></pre>

<h2 id="typematchingandambiguity">Type Matching and Ambiguity</h2>

<p>Because of the duck type nature of Monkey C, ambiguity is inherit to Monkey Types. Ideally, type systems would have very clear rules for if a type does or doesn&#8217;t match, but Monkey Types has True, False, and Maybe<a href="#fn:6" id="fnref:6" title="see footnote" class="footnote">[6]</a>.</p>

<p>Assuming we have the following:</p>

<pre><code class="type">var a as A;
var b as B;

a = b; // Is this assigment allowed?
</code></pre>

<p>You can use the following table</p>

<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>A↓ B→</th>
	<th>Any</th>
	<th>Concrete</th>
	<th>Poly</th>
	<th>Interface</th>
	<th>Container</th>
	<th>Dictionary</th>
	<th>Enum</th>
	<th>Callback</th>
	<th>Null</th>
</tr>
</thead>

<tbody>
<tr>
	<td><strong>Any</strong></td>
	<td>True</td>
	<td>True</td>
	<td>True</td>
	<td>True</td>
	<td>True</td>
	<td>True</td>
	<td>True</td>
	<td>True</td>
	<td>True</td>
</tr>
<tr>
	<td><strong>Concrete</strong></td>
	<td>Maybe</td>
	<td>True if B is or extends A</td>
	<td>Maybe if one of the poly types in B matches A, False otherwise</td>
	<td>False</td>
	<td>Maybe if A is a Dictionary or Array</td>
	<td>Maybe if A is a Dictionary, False otherwise</td>
	<td>True if enum value type matches A, False otherwise</td>
	<td>False</td>
	<td>False</td>
</tr>
<tr>
	<td><strong>Poly</strong></td>
	<td>Maybe</td>
	<td>True if B is a type within A, False otherwise</td>
	<td>True if all references exist in both A and B. Maybe if there are some types in B not in A. False if no matching types between B and A</td>
	<td>True if B is a type within A, False otherwise</td>
	<td>True if B is a type within A, False otherwise</td>
	<td>True if B is a type within A, False otherwise</td>
	<td>True if B is a type within A, False otherwise</td>
	<td>True if B is a type within A, False otherwise</td>
	<td>True if B is a type within A, False otherwise</td>
</tr>
<tr>
	<td><strong>Interface</strong></td>
	<td>Maybe</td>
	<td>True if B is an object that contains all members of interface A, False otherwise</td>
	<td>Maybe if the poly contains a matching type</td>
	<td>True if B&#8217;s interface contains all members in A.</td>
	<td>True if classes Array or Dictionary contains all members of interface, False otherwise</td>
	<td>True if class Dictionary contains all members of interface, False otherwise</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
</tr>
<tr>
	<td><strong>Container</strong></td>
	<td>Maybe</td>
	<td>False</td>
	<td>Maybe if one of the poly types in B matches A, False otherwise</td>
	<td>False</td>
	<td>True if container type and key/value types match exactly, False otherwise</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
</tr>
<tr>
	<td><strong>Dictionary</strong></td>
	<td>Maybe</td>
	<td>False</td>
	<td>Maybe if one of the poly types in B matches A, False otherwise</td>
	<td>False</td>
	<td>True if all keys match the key type and values match the value type (if applicable), False otherwise</td>
	<td>True if all keys match the key type and values match the value type (if applicable), False otherwise</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
</tr>
<tr>
	<td><strong>Enum</strong></td>
	<td>Maybe</td>
	<td>True if value type of enum value B matches concrete type A</td>
	<td>Maybe if one of the poly types in B matches A, False otherwise</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
	<td>True if enum types match, false otherwise</td>
	<td>False</td>
	<td>False</td>
</tr>
<tr>
	<td><strong>Callback</strong></td>
	<td>Maybe</td>
	<td>False</td>
	<td>Maybe if one of the poly types in B matches A, False otherwise</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
	<td>True if function signatures match, False otherwise</td>
	<td>False</td>
</tr>
<tr>
	<td><strong>Null</strong></td>
	<td>Maybe</td>
	<td>False</td>
	<td>Maybe if one of the poly types in B matches A, False otherwise</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
	<td>True</td>
</tr>
</tbody>
</table>

<p>The type checker can run at three different levels based on your level of comfort with ambiguity.</p>

<ol>
<li><strong>Silent</strong> - Type match failures are marked as errors, but ambiguity is ignored</li>
<li><strong>Warning</strong> - Type match failures are marked as errors, and ambiguity is marked as a warning</li>
<li><strong>Error</strong> - Type match failures and ambiguity are marked as errors</li>
</ol>

<p>Compiling a code base with ambiguity muted can find obvious type errors, while compiling code when erroring on ambiguity requires adding type scaffolding throughout the code. Monkey Types is designed to allow you to build towards aggressive typing if you choose to, while still adding value if you don&#8217;t.</p>

<h2 id="typingwithinfunctions">Typing Within Functions</h2>

<p>Up until now we have been explicitly adding type scaffolding. While this makes for very readable and explicit code, it can add lots of boilerplate to implementation.</p>

<p>Within a function, the Monkey Types system will infer the type of a local variable by tracking assignments. Locals that are unbound to a type can accept any type assignment even after they are assigned a first time.</p>

<pre><code class="typescript">import Toybox.Lang;
import OldMacDonaldsFarm;

function handleDog(dog as Dog, here as Array, there as Array, everywhere as Array) {
    here.add(dog.woofWoof());
    there.add(dog.woofWoof());
    everywhere.add(dog.woofWoof());
}

function handleCat(cat as Cat, here as Array, there as Array, everywhere as Array) {
    here.add(cat.meowMeow());
    there.add(cat.meowMeow());
    everywhere.add(cat.meowMeow());
}

function eieio() {
    var here = [], there = [], everywhere = [];
    var animal = new Dog();
    // Allowed, animal is currently assigned a Dog value
    handleDog(animal, here, there, everywhere);
    animal = new Cat();
    // Allowed, animal is currently assigned a Cat value
    handleCat(animal, here, there, everywhere);
}
</code></pre>

<p>The inference will follow through branches. If the type is unclear based on which branch is taken, the type system will make a poly type of the options until the next assignment.</p>

<pre><code class="typescript">import Toybox.Lang;

function process(a as Boolean) as Boolean? {
    var x = null;

    if(a) {
        x = true;
    }
    // At this point, x is now the poly type
    // Boolean or Null
    return x;
}
</code></pre>

<p>When a value has a known type definition, the type checker will validate if method calls are allowed.</p>

<pre><code class="typescript">import Toybox.Lang;

class A {
    function foo() {};
    function bar() {};
}

function process() {
    var a = new A();
    a.foo(); // Allowed
    a.bar(); // Allowed
    a.fonz(); // Not allowed
}
</code></pre>

<p>Explicitly binding a local to a type is also possible by adding an <code>as</code> clause after the local name and before the initialization.</p>

<pre><code class="typescript">import Toybox.Lang;

function example() {
    var a as Number = 2;
    var b as Array&lt;Number&gt; = [1, 2, 3];
    var c as Dictionary&lt;String, String&gt; = {
        &quot;key&quot;=&gt;&quot;value&quot;
    };
}
</code></pre>

<p>With container types, it is also possible to bind a type to the initialized value. This will put controls on what can be assigned to the container, but allow the local to have any value.</p>

<pre><code class="typescript">import Toybox.Lang;

function example() {
    var a = {} as Dictionary&lt;String, String&gt;;
    a[&quot;key&quot;] = &quot;value&quot; // &lt;-- Assignments to a's value must obey type

    a = null; // &lt;-- a is Any and can be assigned to null
}
</code></pre>

<h3 id="returnvaluesandvoid">Return Values and Void</h3>

<p>By default functions return Any. If you bind a type to a function return value, the type check will ensure that you return values of that type.</p>

<pre><code class="typescript">import Toybox.Lang;

function isTrue() as Boolean {
    return &quot;true&quot;; // Not allowed
}
</code></pre>

<p>If your function does not have a return value, you can use the <code>Void</code> type. This will ensure the function doesn&#8217;t return values and error if a function tries to assign the return value of the function.</p>

<h3 id="anyandtypeambiguity">Any and Type Ambiguity</h3>

<p>Any function parameter without a bound type will be of type Any. The ambiguity of the parameter will percolate to any member it interacts with in an expression. If you provide all type definitions, type checking can protect them from many kinds of common errors. However, just a little ambiguity can prevent any level of checking. Take this example where a function has a result check but does not have a argument type for <code>a</code>.</p>

<pre><code class="typescript">import Toybox.Lang;

function foo(a) as Integer? {
    // a is of type Any, so Monkey Types can't identify what doThis() is being called
    var x = a.doThis();
    // x is of type Any, so we can't know what the result type is
    var y = x + 3;
    // What is Y? What is Why? What is Love?
    return y;
}
</code></pre>

<p>Because <code>a</code> is Any, Monkey Types can&#8217;t make any determination on any members of it, and by proxy Monkey Types can&#8217;t make determination on the results of accessing those members.</p>

<h3 id="typecasting">Type Casting</h3>

<p>The <code>as</code> keyword can also be used in an expression to type cast a value to another type. This can be useful if the type is not clear to the type system.</p>

<pre><code class="typescript">import Toybox.WatchUi;

function process(a as View) {
    (a as MyView).specialMyViewMethod();
}
</code></pre>

<h3 id="runtimetypechecking">Runtime Type Checking</h3>

<p>One of the goals of Monkey Types was to not add any runtime overhead. This allows Monkey Types to work on all Connect IQ compatible products out of the gate, but it does add a cost when it comes to runtime type checking. Put simply: while at compile time you have access to an expressive type system, at runtime <code>instanceof</code> and <code>has</code> have the same limits as they had before. For cases involving poly types of concrete types this can work fine.</p>

<pre><code class="typescript">import Toybox.Lang;

function example(x as Number or Float) as Boolean {
    switch(x) {
        case instanceof Number:
            doNumberImpl(x);
            break;
        case instanceof Float:
            doFloatImpl(x);
            break;
    }
}
</code></pre>

<p>Unfortunately not every scenario can be resolved this way. For example, lets say we had the following scenario:</p>

<pre><code class="typescript">typedef Nimble as interface {
    function isNimble() as Boolean;
}

typedef Quick as interface {
    function isQuick() as Boolean;
}

function handleCandleStick(jack as Nimble or Quick) {
    if(jack instanceof Nimble and jack instanceof Quick) {
        if(jack.isNimble() and jack.isQuick() and jack has :jumpOverCandleStick) {
            x.jumpOverCandleStick();
        }
    }
}
</code></pre>

<p>In the case of <code>handleCandleStick</code> the interfaces <code>Nimble</code> and <code>Quick</code> are lexical types and only exist at compile time. This will cause a compiler error because <code>instanceof</code> can only be used on concrete classes and not lexical types. In this case we can use <code>has</code> to resolve this issue.</p>

<pre><code class="typescript">function handleCandleStick(jack as Nimble or Quick) {
    if(jack has :isNimble and jack has :isQuick and jack has :jumpOverCandleStick) {
        if(jack.isNimble() and jack.isQuick()) {
            x.jumpOverCandleStick();
        }
    }
}
</code></pre>

<h3 id="if-splitting">If-Splitting</h3>

<p>In languages like Java, an object&#8217;s type is assumed to be whatever it was declared to be. This can lead to some very redundant casting or generation of lots of unnecessary locals to communicate to the Compiler that something isn&#8217;t what it was declared to be.</p>

<pre><code class="java">public boolean foo(SomeInterfaceType x) {
    if(x instanceof SomeConcreteType) {
        // My life will just be easier if I make
        // a new variable, even though it should
        // be possible to assume that x is
        // a SomeConcreteType
        SomeConcreteType y = (SomeConcreteType)x;
        // Do operations on y
    }
}
</code></pre>

<p>The Monkey C type system will take advantage of if-splitting, where the branch expression causes the types for local variables to mutate within the true and false cases</p>

<pre><code class="typescript">import Toybox.Lang;

public function foo(x as Number?) as Boolean {
    if(x != null) {
        // Within this block assume x is Number and not null
    } else {
        // Within this block assume x is null
    }
}
</code></pre>

<p>The ==, !=, and <code>instanceof</code> operators will mutate the types based on the following rules</p>

<table>
<colgroup>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:left;">type</th>
	<th style="text-align:left;">==</th>
	<th style="text-align:left;">!=</th>
	<th style="text-align:left;">instanceof</th>
	<th style="text-align:left;">!instanceof</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;">Any</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Mutate type to <code>instanceof</code> type</td>
	<td style="text-align:left;">Ignore</td>
</tr>
<tr>
	<td style="text-align:left;">Concrete</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Mutate type to <code>instanceof</code> type</td>
	<td style="text-align:left;">Ignore</td>
</tr>
<tr>
	<td style="text-align:left;">Poly</td>
	<td style="text-align:left;">If == is <code>null</code>, mutate to Null type</td>
	<td style="text-align:left;">if != is <code>null</code>, mutate to poly type minus <code>null</code>.</td>
	<td style="text-align:left;">Mutate type to <code>instanceof</code> type</td>
	<td style="text-align:left;">Mutate type to poly type minus type from <code>instanceof</code></td>
</tr>
<tr>
	<td style="text-align:left;">Interface</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Mutate type to <code>instanceof</code> type</td>
	<td style="text-align:left;">Ignore</td>
</tr>
<tr>
	<td style="text-align:left;">Container</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
</tr>
<tr>
	<td style="text-align:left;">Dictionary</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
</tr>
<tr>
	<td style="text-align:left;">Enum</td>
	<td style="text-align:left;">Mutate to enum value type</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
</tr>
<tr>
	<td style="text-align:left;">Callback</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
</tr>
<tr>
	<td style="text-align:left;">Null</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
</tr>
</tbody>
</table>

<p>Expressions can also be modified using the &amp;&amp; and || operators. With the &amp;&amp; operator, the mutation will carry through the expression, being further modified as the expression continues.</p>

<pre><code class="typescript">import Toybox.Lang;

type Addable as Number or Float or Long or Double or String;

public function foo(x as Addable?) {
    // In the first clause, x is modified to remove the null
    // from the poly type. In the second clause, the new polytype
    // is modified to be a String concrete type.
    if(x != null &amp;&amp;
       x instanceof String) {
        // Within this block assume x is a string
    }
}
</code></pre>

<p>With || operators, a new poly type is created with the results of both operations</p>

<pre><code class="typescript">import Toybox.Lang;

type Addable as Number or Float or Long or Double or String;

public function foo(x as Addable?) {
    if(x instanceof Number ||
       x instanceof Float) {
        // Within this block assume x is a Number or Float
    }
}
</code></pre>

<h2 id="moduleandclasstyping">Module and Class Typing</h2>

<h3 id="typingmembervariables">Typing Member Variables</h3>

<p>Class member variables are bound to type Any by default. Unlike local variables, member variables are not type inferenced based on assignment. Adding type scaffolding to your member variables and names to your enumerations will allow for stronger type checking.</p>

<p>Likewise, if you add type scaffolding you must either initialize the variable or allow it to be <code>null</code>. The below example will cause a compiler error:</p>

<pre><code class="typescript">import Toybox.Lang;

var globalString as String;

function printGlobalString() {
    System.println(globalString);
}
</code></pre>

<p>The reason for the error is that <code>globalString</code> is declared as a String, but left alone it&#8217;s initialized as <code>null</code>. Module variables either have to be initialized at declaration or allow it to be <code>null</code>, while object members can be initialized in the <code>initialize</code> function as well.</p>

<h3 id="typesandinheritance">Types and Inheritance</h3>

<p>When extending classes, the type system will use the following rules:</p>

<ol>
<li>If you extend a function from a parent with the same number of arguments but do not add type decoration, the types for the arguments and return value will be transferred verbatim from the parent implementation</li>
<li>If you extend a function from a parent with the same number of arguments and add type decoration, you must match the number of arguments and type decoration exactly or the compiler will error</li>
</ol>

<p>This allows for existing Monkey C code that extends <code>Toybox</code> types to take advantage of type checking without having to add any type decoration.</p>

<div class="footnotes">
<hr />
<ol>

<li id="fn:1">
<p>This is different than Monkey Typing, where a thousand monkeys over infinite time write the works of Shakespeare. <a href="#fnref:1" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:2">
<p>Not that this ever happened to the author. <a href="#fnref:2" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:3">
<p>We are all about conflict avoidance here. <a href="#fnref:3" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:4">
<p>Do not forget to match your bling with pieces of flair; you can&#8217;t have enough of either. <a href="#fnref:4" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:5">
<p>Tofu for the vegetarians, BBQ for Kansans&hellip; <a href="#fnref:5" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:6">
<p>I just met you | and this is crazy | but I&#8217;m an Any | so type match? Maybe&#8230; <a href="#fnref:6" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

</ol>
</div>


</body>
</html>
